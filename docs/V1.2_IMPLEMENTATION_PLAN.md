# Version 1.2 Implementation Plan: Quick HTTP Profile

**Version**: 1.2  
**Date**: October 2025  
**Status**: 🟣 Planned  
**Goal**: Enable ultra-fast bulk scanning of 150k+ domains through HTTP check optimization

---

## 📊 Executive Summary

### Problem Statement
Current `quick-check` profile uses full HTTP GET requests with 10-second timeouts, making bulk scans of 150k domains take ~40 hours. This blocks the two-phase scanning workflow where we want to:
1. Quickly filter domains (registered + active)
2. Run detailed analysis on filtered subset

### Solution
Split HTTP checking into two profiles mirroring the successful `quick-whois` pattern:
- **`quick-http`**: HEAD requests, 2s timeout → Fast filtering (~0.5-2s per domain)
- **`http`**: GET requests, 10s timeout → Detailed analysis (~2-10s per domain)

### Expected Impact
- **Current workflow**: 150k domains × 30s avg = ~40 hours
- **New workflow**: 150k domains × 2s avg = ~4 hours (Phase 1) + 80k domains × 10s avg = ~10 hours (Phase 2) = **~14 hours total**
- **Time savings**: ~65% reduction (26 hours saved)

---

## 🎯 Implementation Phases

### Phase 1: Create Quick HTTP Check (Priority: HIGH)
**Estimated effort**: 4-6 hours

#### File: `src/checks/quick_http_check.py` (NEW)

**Implementation details:**

```python
"""
Quick HTTP connectivity check using HEAD requests.

Purpose: Fast active/inactive classification for bulk domain filtering.
Method: HTTP HEAD request (no body download)
Timeout: 2 seconds (aggressive fail-fast)
Protocols: HTTPS first, HTTP fallback
"""

import aiohttp
import asyncio
import time
from typing import Dict, Any
from datetime import datetime


async def run_quick_http_check(domain: str, config: Dict) -> Dict[str, Any]:
    """
    Perform ultra-fast HTTP connectivity check using HEAD request.
    
    Args:
        domain: Domain name to check (e.g., 'example.lt')
        config: Configuration dict from config.yaml
        
    Returns:
        Dict containing:
        - status: 'active' or 'inactive'
        - http_status: HTTP status code (if active)
        - protocol: 'http' or 'https' (which one worked)
        - final_url: URL after redirects
        - redirect_count: Number of redirects followed
        - response_time_ms: Response time in milliseconds
        - error: Error message (if inactive)
    """
    
    # Configuration with aggressive timeouts
    timeout_config = config.get('checks', {}).get('quick-http', {})
    total_timeout = timeout_config.get('timeout', 2.0)
    connect_timeout = timeout_config.get('connect_timeout', 1.0)
    sock_read = timeout_config.get('sock_read_timeout', 0.5)
    max_redirects = timeout_config.get('max_redirects', 5)
    
    timeout = aiohttp.ClientTimeout(
        total=total_timeout,
        connect=connect_timeout,
        sock_read=sock_read
    )
    
    # Connection pooling and DNS caching for performance
    connector = aiohttp.TCPConnector(
        limit=100,              # Connection pool size
        ttl_dns_cache=300,      # Cache DNS for 5 minutes
        force_close=True,       # Don't keep connections alive (cleaner for bulk)
        enable_cleanup_closed=True
    )
    
    async with aiohttp.ClientSession(
        connector=connector,
        timeout=timeout,
        raise_for_status=False  # Don't raise on 4xx/5xx
    ) as session:
        
        # Try protocols in order: HTTPS first (most common), then HTTP
        protocols = timeout_config.get('protocols', ['https', 'http'])
        
        for protocol in protocols:
            url = f"{protocol}://{domain}"
            start_time = time.time()
            
            try:
                async with session.head(
                    url,
                    allow_redirects=True,
                    max_redirects=max_redirects,
                    ssl=False if protocol == 'http' else None  # Skip SSL verify for HTTP
                ) as response:
                    
                    elapsed_ms = int((time.time() - start_time) * 1000)
                    
                    return {
                        'status': 'active',
                        'http_status': response.status,
                        'protocol': protocol,
                        'final_url': str(response.url),
                        'redirect_count': len(response.history),
                        'response_time_ms': elapsed_ms,
                        'checked_at': datetime.utcnow().isoformat(),
                    }
                    
            except asyncio.TimeoutError:
                # Timeout on this protocol, try next
                continue
                
            except aiohttp.ClientConnectorError as e:
                # Connection failed (DNS, network, etc.), try next protocol
                continue
                
            except aiohttp.ClientError as e:
                # Other client errors, try next protocol
                continue
        
        # All protocols failed
        return {
            'status': 'inactive',
            'error': 'timeout_or_connection_failed',
            'checked_protocols': protocols,
            'checked_at': datetime.utcnow().isoformat(),
        }


# Async wrapper for orchestrator
async def check_quick_http(domain: str, config: Dict) -> Dict[str, Any]:
    """Wrapper function matching orchestrator pattern."""
    return await run_quick_http_check(domain, config)
```

**Testing checklist:**
- [ ] Works with HTTPS-only sites
- [ ] Fallback to HTTP works
- [ ] 2-second timeout enforced
- [ ] Correctly identifies inactive domains
- [ ] Follows redirects (up to max_redirects)
- [ ] Returns accurate response time
- [ ] Handles DNS failures gracefully
- [ ] Connection pooling improves performance

---

### Phase 2: Update Full HTTP Check (Priority: HIGH)
**Estimated effort**: 2-3 hours

#### File: `src/checks/http_check.py` (MODIFY EXISTING)

**Required changes:**

1. **Switch from HEAD to GET requests:**
```python
# OLD:
async with session.head(url, ...) as response:

# NEW:
async with session.get(url, ...) as response:
    content = await response.read()  # Download body
```

2. **Add content analysis:**
```python
def analyze_response_content(response, content):
    """Extract content metrics from GET response."""
    return {
        'content_length': len(content),
        'compression': response.headers.get('Content-Encoding'),
        'content_type': response.headers.get('Content-Type'),
        'server': response.headers.get('Server'),
        'http_version': f"HTTP/{response.version.major}.{response.version.minor}",
    }
```

3. **Add performance metrics:**
```python
# Time to first byte (TTFB)
ttfb_start = time.time()
async with session.get(url, ...) as response:
    ttfb = int((time.time() - ttfb_start) * 1000)
    # ... rest of response handling
```

4. **Enhanced return data:**
```python
return {
    'status': 'active',
    'http_status': response.status,
    'protocol': protocol,
    'final_url': str(response.url),
    'redirect_count': len(response.history),
    'redirect_chain': [str(r.url) for r in response.history],
    'response_time_ms': elapsed_ms,
    'ttfb_ms': ttfb,
    'content_length': len(content),
    'compression': response.headers.get('Content-Encoding'),
    'server': response.headers.get('Server'),
    'http_version': f"HTTP/{response.version.major}.{response.version.minor}",
    'checked_at': datetime.utcnow().isoformat(),
}
```

**Testing checklist:**
- [ ] Uses GET instead of HEAD
- [ ] Downloads and analyzes content
- [ ] Tracks full redirect chain
- [ ] Measures TTFB accurately
- [ ] Extracts server/compression info
- [ ] 10-second timeout maintained
- [ ] Backward compatible with existing data

---

### Phase 3: Database Schema Updates (Priority: HIGH)
**Estimated effort**: 1 hour

#### File: `db/schema.sql` (MODIFY EXISTING)

**Add new columns to `domains` table:**

```sql
-- Migration script for v1.2
-- Add activity tracking columns

ALTER TABLE domains 
  ADD COLUMN IF NOT EXISTS is_active_source VARCHAR(50),
  ADD COLUMN IF NOT EXISTS is_active_updated_at TIMESTAMP;

-- Add comments for documentation
COMMENT ON COLUMN domains.is_active IS 'Whether domain has active website (responds to HTTP)';
COMMENT ON COLUMN domains.is_active_source IS 'Source that set is_active: quick-http, http, manual, etc.';
COMMENT ON COLUMN domains.is_active_updated_at IS 'When is_active was last updated';

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_domains_is_active 
  ON domains(is_active);

CREATE INDEX IF NOT EXISTS idx_domains_active_registered 
  ON domains(is_active, is_registered);

CREATE INDEX IF NOT EXISTS idx_domains_active_source 
  ON domains(is_active_source);

-- Backfill existing data (set source for existing is_active values)
UPDATE domains 
SET 
  is_active_source = 'legacy',
  is_active_updated_at = COALESCE(updated_at, created_at)
WHERE 
  is_active IS NOT NULL 
  AND is_active_source IS NULL;
```

**Update `db/setup.sh`** to apply migration:
```bash
# Add to setup script
echo "Applying v1.2 schema updates..."
psql $DATABASE_URL -c "ALTER TABLE domains ADD COLUMN IF NOT EXISTS is_active_source VARCHAR(50);"
psql $DATABASE_URL -c "ALTER TABLE domains ADD COLUMN IF NOT EXISTS is_active_updated_at TIMESTAMP;"
psql $DATABASE_URL -c "CREATE INDEX IF NOT EXISTS idx_domains_is_active ON domains(is_active);"
psql $DATABASE_URL -c "CREATE INDEX IF NOT EXISTS idx_domains_active_registered ON domains(is_active, is_registered);"
```

**Testing checklist:**
- [ ] Migration runs successfully on existing database
- [ ] Indexes created correctly
- [ ] Backfill completes without errors
- [ ] No data loss during migration
- [ ] NULL values handled properly

---

### Phase 4: Profile System Updates (Priority: HIGH)
**Estimated effort**: 2 hours

#### File: `src/profiles/profile_schema.py` (MODIFY EXISTING)

**Add `quick-http` profile:**

```python
# ProfileType enum
class ProfileType(str, Enum):
    # ... existing profiles ...
    QUICK_HTTP = "quick-http"
    
# PROFILE_DEPENDENCIES
PROFILE_DEPENDENCIES: Dict[str, List[str]] = {
    # Core profiles
    'quick-whois': [],
    'quick-http': [],  # NEW
    'whois': [],
    'http': [],
    'dns': [],
    'ssl': [],
    
    # Meta profiles
    'quick-check': ['quick-whois', 'quick-http'],  # UPDATED
    'standard': ['whois', 'dns', 'http', 'ssl', 'seo'],  # Uses full http
    # ... rest unchanged ...
}

# PROFILE_METADATA
PROFILE_METADATA: Dict[str, Dict[str, Any]] = {
    'quick-http': {
        'category': ProfileCategory.CORE,
        'description': 'Fast HTTP connectivity check (HEAD request only)',
        'data_source': 'HTTP/HTTPS HEAD requests',
        'api_calls': 2,  # HTTPS + HTTP fallback
        'duration_estimate': '0.5-2s',
        'rate_limit': None,
        'use_cases': [
            'Bulk domain filtering',
            'Active/inactive classification',
            'Quick connectivity verification',
            'Pre-screening before detailed analysis'
        ],
        'output_fields': [
            'status',
            'http_status',
            'protocol',
            'final_url',
            'redirect_count',
            'response_time_ms'
        ],
    },
    'http': {
        'category': ProfileCategory.CORE,
        'description': 'Complete HTTP analysis with content inspection (GET request)',
        'data_source': 'HTTP/HTTPS GET requests',
        'api_calls': 2,
        'duration_estimate': '2-10s',
        'rate_limit': None,
        'use_cases': [
            'Detailed redirect analysis',
            'Performance metrics collection',
            'Content and header inspection',
            'Server technology detection'
        ],
        'output_fields': [
            'status',
            'http_status',
            'protocol',
            'final_url',
            'redirect_chain',
            'response_time_ms',
            'ttfb_ms',
            'content_length',
            'compression',
            'server',
            'http_version'
        ],
    },
    # ... rest unchanged ...
}
```

**Testing checklist:**
- [ ] `quick-http` profile loads correctly
- [ ] `quick-check` expands to ['quick-whois', 'quick-http']
- [ ] Profile metadata accessible
- [ ] No circular dependencies
- [ ] Backward compatibility maintained

---

### Phase 5: Orchestrator Early Bailout (Priority: MEDIUM)
**Estimated effort**: 3-4 hours

#### File: `src/orchestrator.py` (MODIFY EXISTING)

**Add inactive domain filtering:**

```python
class DomainOrchestrator:
    
    def determine_checks_to_run(self, domain_obj, profiles: List[str]) -> List[str]:
        """
        Determine which checks to run based on domain state and requested profiles.
        
        Implements early bailout optimization:
        - Unregistered domains: Only run registration checks
        - Inactive domains: Skip content-based checks
        """
        
        # Early bailout: Unregistered domains (v1.1)
        if domain_obj.is_registered == False:
            # Only try to verify registration status
            if 'whois' in profiles or 'quick-whois' in profiles:
                return ['whois']
            return []
        
        # Early bailout: Inactive domains (v1.2 NEW)
        if domain_obj.is_active == False:
            # Check if requested profiles require active website
            if self.requires_active_site(profiles):
                # Skip content-based checks, only run connectivity checks
                allowed = ['quick-whois', 'whois', 'quick-http', 'http', 'dns', 'ssl']
                return [p for p in profiles if p in allowed]
        
        # No bailout needed, run all requested checks
        return self.expand_profiles(profiles)
    
    def requires_active_site(self, profiles: List[str]) -> bool:
        """
        Check if any requested profile requires an active website.
        
        Content-based profiles that need active site:
        - seo: Needs to crawl pages
        - content: Needs to download HTML
        - headers: Needs HTTP response (but could work on inactive)
        - robots: Needs to fetch robots.txt
        - sitemap: Needs to fetch sitemap.xml
        """
        content_profiles = {
            'seo', 'content', 'robots', 'sitemap', 'headers',
            'business', 'language', 'technology'
        }
        return any(p in content_profiles for p in profiles)
    
    async def update_domain_flags(self, domain_obj, check_results: Dict):
        """
        Update domain flags (is_registered, is_active) based on check results.
        
        Args:
            domain_obj: Domain database object
            check_results: Dict of check results
        """
        db_updates = {}
        
        # Update is_registered from whois/quick-whois
        if 'whois' in check_results or 'quick-whois' in check_results:
            whois_data = check_results.get('whois', check_results.get('quick-whois'))
            if whois_data and whois_data.get('status') == 'registered':
                db_updates['is_registered'] = True
            else:
                db_updates['is_registered'] = False
        
        # Update is_active from quick-http/http (v1.2 NEW)
        if 'quick-http' in check_results:
            quick_http_data = check_results.get('quick-http')
            if quick_http_data:
                db_updates['is_active'] = (quick_http_data.get('status') == 'active')
                db_updates['is_active_source'] = 'quick-http'
                db_updates['is_active_updated_at'] = 'NOW()'
        
        elif 'http' in check_results:
            http_data = check_results.get('http')
            if http_data:
                db_updates['is_active'] = (http_data.get('status') == 'active')
                db_updates['is_active_source'] = 'http'
                db_updates['is_active_updated_at'] = 'NOW()'
        
        # Apply updates to database
        if db_updates:
            await self.db.update_domain(domain_obj.id, db_updates)
```

**Add check mapping:**

```python
# In orchestrator's check mapping dict
CHECK_FUNCTIONS = {
    'quick-whois': run_whois_check,  # Existing
    'quick-http': run_quick_http_check,  # NEW
    'whois': run_whois_check,
    'http': run_http_check,
    # ... rest ...
}
```

**Testing checklist:**
- [ ] Inactive domains skip content checks
- [ ] Active domains run all requested checks
- [ ] `is_active` flag updates correctly
- [ ] `is_active_source` tracks check source
- [ ] Early bailout saves time (benchmark)
- [ ] Manual override possible

---

### Phase 6: Configuration Updates (Priority: LOW)
**Estimated effort**: 30 minutes

#### File: `config.yaml` (MODIFY EXISTING)

**Add quick-http configuration:**

```yaml
checks:
  quick-http:
    enabled: true
    timeout: 2.0              # Total timeout (aggressive)
    connect_timeout: 1.0      # Connection establishment
    sock_read_timeout: 0.5    # Socket read timeout
    max_redirects: 5          # Limit redirect chains
    protocols:                # Try in order
      - https
      - http

  http:
    enabled: true
    timeout: 10.0             # Longer timeout for full analysis
    connect_timeout: 3.0
    sock_read_timeout: 5.0
    max_redirects: 10

# ... rest of config ...

profiles:
  quick-http:
    enabled: true
    checks:
      - connectivity_status
      
  http:
    enabled: true
    checks:
      - connectivity_status
      - redirect_analysis
      - performance_metrics
      - content_analysis
```

---

### Phase 7: Documentation Updates (Priority: MEDIUM)
**Estimated effort**: 2 hours

**Files to update:**

1. **`docs/TASK_PROFILES.md`**: Add `quick-http` profile documentation
2. **`docs/PROFILE_QUICK_REFERENCE.md`**: Update comparison table
3. **`README.md`**: Update performance benchmarks
4. **`CHANGELOG.md`**: Add v1.2 entry

**Example documentation:**

```markdown
## quick-http Profile

**Purpose**: Ultra-fast HTTP connectivity check for bulk domain filtering

**Method**: HTTP HEAD request (no body download)

**Speed**: ~0.5-2 seconds per domain

**Use Cases**:
- Bulk domain screening (150k+ domains)
- Active/inactive classification
- Pre-filtering before detailed analysis
- Two-phase scanning workflows

**What It Checks**:
- ✅ HTTP/HTTPS connectivity
- ✅ Response status code
- ✅ Basic redirect following
- ✅ Response time

**What It Doesn't Check**:
- ❌ Page content
- ❌ Full redirect chain analysis
- ❌ Server headers (beyond status)
- ❌ Performance metrics (TTFB, etc.)

**Example Usage**:
```bash
# Phase 1: Quick filtering (150k domains in ~4 hours)
python -m src.orchestrator domains.txt --profiles quick-check

# Phase 2: Detailed analysis (80k active domains in ~10 hours)
python -m src.orchestrator active_domains.txt --profiles standard
```

**Performance**:
- Average: 0.5-2s per domain
- Active domain: ~0.5s (fast response)
- Inactive domain: ~2s (timeout)
- For 150k domains: ~2-4 hours total
```

---

## 🧪 Testing Strategy

### Unit Tests
**File**: `tests/unit/test_quick_http.py` (NEW)

```python
import pytest
from src.checks.quick_http_check import run_quick_http_check

@pytest.mark.asyncio
async def test_quick_http_active_domain():
    """Test quick-http on known active domain."""
    config = {'checks': {'quick-http': {'timeout': 2.0}}}
    result = await run_quick_http_check('google.com', config)
    
    assert result['status'] == 'active'
    assert result['http_status'] == 200
    assert result['protocol'] in ['http', 'https']
    assert 'final_url' in result

@pytest.mark.asyncio
async def test_quick_http_inactive_domain():
    """Test quick-http on inactive domain."""
    config = {'checks': {'quick-http': {'timeout': 2.0}}}
    result = await run_quick_http_check('nonexistent-domain-12345.lt', config)
    
    assert result['status'] == 'inactive'
    assert 'error' in result

@pytest.mark.asyncio
async def test_quick_http_timeout():
    """Test timeout handling."""
    config = {'checks': {'quick-http': {'timeout': 0.1}}}  # Very short
    result = await run_quick_http_check('example.com', config)
    
    # Should timeout and mark inactive
    assert result['status'] == 'inactive'
```

### Integration Tests
**File**: `tests/integration/test_quick_http_workflow.py` (NEW)

```python
@pytest.mark.asyncio
async def test_quick_check_profile():
    """Test full quick-check profile (quick-whois + quick-http)."""
    orchestrator = DomainOrchestrator(config, db_url)
    result = await orchestrator.process_domain('example.lt', ['quick-check'])
    
    assert 'quick-whois' in result['checks']
    assert 'quick-http' in result['checks']
    assert result['meta']['is_registered'] in [True, False]
    assert result['meta']['is_active'] in [True, False]
```

### Performance Benchmarks
**File**: `tests/performance/benchmark_quick_http.py` (NEW)

```python
async def benchmark_quick_http():
    """Benchmark quick-http vs full http."""
    domains = ['example.lt', 'google.com', 'facebook.com', ...]
    
    # Benchmark quick-http
    start = time.time()
    for domain in domains:
        await run_quick_http_check(domain, config)
    quick_time = time.time() - start
    
    # Benchmark full http
    start = time.time()
    for domain in domains:
        await run_http_check(domain, config)
    full_time = time.time() - start
    
    print(f"quick-http: {quick_time:.2f}s")
    print(f"full http: {full_time:.2f}s")
    print(f"Speedup: {full_time/quick_time:.1f}x")
```

---

## 📋 Implementation Checklist

### Code Changes
- [ ] Create `src/checks/quick_http_check.py`
- [ ] Modify `src/checks/http_check.py` (HEAD → GET)
- [ ] Update `src/profiles/profile_schema.py`
- [ ] Update `src/orchestrator.py` (early bailout)
- [ ] Update `config.yaml`

### Database Changes
- [ ] Add `is_active_source` column
- [ ] Add `is_active_updated_at` column
- [ ] Create indexes
- [ ] Test migration on dev database
- [ ] Backfill existing data

### Testing
- [ ] Unit tests for `quick_http_check.py`
- [ ] Unit tests for updated `http_check.py`
- [ ] Integration tests for `quick-check` profile
- [ ] Integration tests for early bailout
- [ ] Performance benchmarks
- [ ] Test on sample dataset (1000 domains)

### Documentation
- [ ] Update `TASK_PROFILES.md`
- [ ] Update `PROFILE_QUICK_REFERENCE.md`
- [ ] Update `README.md`
- [ ] Update `CHANGELOG.md`
- [ ] Update `LAUNCH_PLAN.md` (mark v1.2 complete)
- [ ] Create migration guide

### Deployment
- [ ] Test on staging environment
- [ ] Run full test suite
- [ ] Performance validation (benchmark)
- [ ] Deploy to production
- [ ] Monitor first 1000 domain scans
- [ ] Tag release: `git tag v1.2`

---

## 🎯 Success Metrics

### Performance
- ✅ `quick-http` completes in <2s per domain (95th percentile)
- ✅ 150k domain scan with `quick-check`: <4 hours
- ✅ Overall speedup vs old workflow: >10x

### Accuracy
- ✅ False positive rate (inactive marked as active): <2%
- ✅ False negative rate (active marked as inactive): <5%
- ✅ Agreement with full `http` check: >95%

### Data Quality
- ✅ `is_active` flag set for >99% of domains
- ✅ `is_active_source` tracked correctly
- ✅ No data loss during migration

### Adoption
- ✅ `quick-check` becomes default for bulk scans
- ✅ Two-phase workflow documented and tested
- ✅ User satisfaction with speed improvement

---

## 🚀 Deployment Plan

### Pre-Deployment
1. Merge all code changes to `main` branch
2. Run full test suite: `pytest tests/ -v`
3. Performance benchmark on 1000 domains
4. Code review and approval

### Deployment Steps
1. **Backup production database**
   ```bash
   pg_dump $DATABASE_URL > backup_pre_v1.2.sql
   ```

2. **Apply database migration**
   ```bash
   psql $DATABASE_URL < db/migrations/v1.2_add_activity_tracking.sql
   ```

3. **Deploy code to production**
   ```bash
   ./deploy.sh
   ```

4. **Verify deployment**
   ```bash
   # Test quick-http on single domain
   python -m src.orchestrator --domain example.lt --profiles quick-http
   
   # Test quick-check profile
   python -m src.orchestrator --domain example.lt --profiles quick-check
   ```

5. **Monitor initial scans**
   - Watch logs for errors
   - Check database for correct flag updates
   - Validate performance metrics

### Rollback Plan
If issues detected:
```bash
# Restore database
psql $DATABASE_URL < backup_pre_v1.2.sql

# Revert code
git checkout v1.1
./deploy.sh
```

---

## 📞 Support & Questions

**Implementation questions**: Review this document and LAUNCH_PLAN.md  
**Technical issues**: Check logs in `logs/` directory  
**Performance concerns**: Run benchmark in `tests/performance/`  

**Key contacts**: Project maintainer

---

**Document Version**: 1.0  
**Last Updated**: October 2025  
**Next Review**: After v1.2 deployment
